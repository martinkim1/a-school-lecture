import random

print("***** 데이터베이스 빈칸문제 출제 프로그램 *****")
print("스페이스(공백)을 구별합니다. 정확히 입력해주세요.")

questions = [
                "(   )는 현실 세계에서 관찰 또는 수집의 결과로 나타난 사실이다.",
				"수집된 데이터를 저장했다가 필요할 때 제공하는 역할은 정보 시스템의 핵심인 (   )가 담당한다.",
				"기업들이 독립적인 부서를 통해 조직의 전체 데이터를 관리하게 하고 (   )라는 최고 경영자를 임명하여 의사결정에 필요한 정보를 관장하게 하는 이유는 그만큼 기업 경쟁력의 핵심 요소이기 때문이다.",
				"(   )은 중복되거나 연관된 데이터 간의 의미적 불일치성 혹은 모순성이 없는 상태를 말한다.",
				"(   )은 저장된 데이터 값이 현실 세계의 실제 값과 얼마나 정확히 일치하는지를 뜻하는 의미적 정확성을 말한다.",
				"데이터베이스 시스템에서는 모든 응용 프로그램이나 사용자들은 (   )를 통해서만 데이터 처리가 가능하다.",
				"데이터베이스 관리자인 DBA는 (   )의 약어이다.",
				"(   ) 용어는 원래 좁은 의미에서는 데이터 검색을 위한 데이터 조작어를 의미했지만 현재 넓은 의미에서는 데이터의 검색뿐만 아니라 입력, 수정, 삭제 그리고, 데이터 정의 기능 까지를 포함하는 광범위한 기능을 가진 독립적인 언어를 뜻하는 것으로 사용되고 있다.",
				"(   )는 데이터베이스를 효율적으로 관리하고 데이터베이스에 대한 데이터 요청을 처리하는 소프트웨어이다.",
				"(   ) 데이터 모델은 객체 단위의 저장 구조를 가지며 연관된 데이터 사이의 관계를 객체식별자로 표현하는 저장 방식이다.",
				"데이터베이스와 DBMS의 종류를 분류하는 가장 중요한 기준은 바로 (   )이다.",
				"(   )는 모든 데이터베이스 사용자들의 관점을 통합하여 조직이나 기관의 데이터베이스 전체를 명세한 데이터베이스 구조이다",
				"데이터베이스를 구성하는 모든 테이블들의 구조를 명세한 것이 (   )이다.",
				"(   )은 데이터베이스에 저장된 모든 부가 정보 즉, 데이터 정의나 명세뿐만 아니라 스키마와 이들 간의 사상 정보, 제약 조건 등을 저장하는 저장소이다.",
				"개념적 스키마에 영향이 없도록 하면서 데이터베이스의 물리적 구조를 변경할 수 있는 것을 (   )이라 한다.",
				"데이터 모델은 데이터 구조와 연산, (   ) 3가지 요소를 명세한다.",
				"관계형 데이터베이스(relational database)는 1970년대 IBM 연구소의 (   )가 제안한 관계형 데이터 모델에 기반하고 있다.",
				"각 속성이 취할 수 있는 모든 값들의 집합을 정의한 것을 (   )이라 한다.", "관계형 데이터베이스 스키마는 (   ) 스키마들의 모임이다.",
				"후보키는 유일성과 (   ) 조건을 모두 만족해야 한다.", "후보키를 포함하는 속성 집합은 모두 (   )가 된다.",
				"후보키 중에서 적절한 기본키 선정이 어려울 경우, 일련번호 같은 인위적인 속성을 추가로 생성하여 지정하는 기본키를 (   )라고 한다.",
				"기본키와 (   )는 릴레이션 간의 관계성을 표현하기 위해서 사용된다.",
				"관계형 데이터 모델에서 (ㄱ)(은)는 속성들을 갖는 2차원 테이블이며 속성은 각 열을, (ㄴ)(은)는 각 행을 의미한다. 또한, (ㄷ)(은)는 속성의 수를 의미하며, 행의 개수는 (ㄹ)(이)라 한다.",
				"(    )은 자연 조인 결과에 포함되지 않는 조인에 실패한 투플까지 모두 포함하도록 확장한 자연 조인 연산이다.",
				"관계 대수는 수학 집합 이론에 기반을 둔 (   ) 연산 그룹과 관계형 데이터 모델을 위해 추가된 (   ) 연산 그룹 2개의 그룹으로 분류한다.",
				"집합 연산(set operation) 그룹은 합집합, 교집합, 차집합, (   )연산을 포함한다.",
				"(   ) 가능하려면 두 릴레이션의 차수(속성 개수)가 같고 대응하는 속성의 순서와 도메인이 같아야 한다.",
				"(   ) 연산은 릴레이션에서 특정 투플을 추출하는 연산으로 연산자는 시그마 (sigma)를 사용한다.",
				"(   ) 연산은 결과적으로 카티션 프로덕트의 결과 릴레이션 중에서 '조인_조건식'을 만 족하는 투플을 셀렉트한 것과 같다.",
				"(   )은 동등 조인 결과 중에서 '조인조건식'에 사용된 중복 속성을 자동 제거한 조인이다.", "자연 조인은 (   )조인이면서 세타 조인이기도 하다.",
				"(   )은 자연 조인이 반환하는 결과 릴레이션 중에서 한쪽 릴레이션 속성만으로 한정하여 반환하는 제한적 자연 조인 연산이다.",
				"(   ) 조인을 수행하면 릴레이션 안의 모든 투플이 빠짐없이 결과 릴레이션에 포함된다.",
				"작성된 후보 관계 대수식은 DBMS 안의 질의 최적화 과정을 위해 내부적으로 (   )로 변환되어 표현된다.",
				"관계형 데이터베이스 표준 언어인 SQL은 (   )의 약어이다.", "SQL은 대화식 그리고 (   )의 2가지 방식으로 사용할 수 있다.",
				"univDB로 작업 대상 데이터베이스를 변경하는 명령은 (   ) univDB'이다.", "SELECT절의 ‘(*)'는 테이블의 모든 열 이름을 나열한 것과 같다.",
				"조건을 만족하는 결과가 존재하는지만 알고 싶거나 그 중 일부만 검색하고자 하는 경우 (   )키워드를 사용한다.",
				"집계 함수는 그룹 함수와 밀접한 관련성이 있으며 SELECT절이나 (   )절에만 사용할 수 있다.",
				"SELECT절에서 연산이나 집계 함수의 적용 결과로 새로운 값을 반환할 때 새로운 이름인 별칭을 정의하는 키워드는 (   )이다.",
				"(   )은 질의문 안에 중첩(   )되어 포함된 또 다른 SELECT 검색문을 말한다.",
				"WHERE절에 사용되는 (   ) 연산자는 괄호 안에 나열된 값들 중에서 하나라도 일치하는 경우 참(   )을 반환하는 연산자이다.",
				"(   ) 연산자는 부 질의문의 실행 결과로 반환되는 행이 존재하는지 존재 유무를 확인 하는 연산자이다.",
				"중첩 질의문 중에서 내부 질의의 WHERE절 검색조건식이 외부 질의에 선언된 테이블의 일부 열을 참조하는 질의를 (   )이라고 한다.",
				"FROM절에 명세한 조인 대상 테이블이 n개이면 (   )개의 조인 조건식이 필요하다.", "생성된 학생 테이블의 구조를 확인하는 명령은 ‘(   ) 학생'이다.",
				"계정에게 부여한 권한은 (   )명령문을 통해 다시 철회할 수 있다.", "뷰의 장점은 편의성, (   ), 재사용성, 독립성이다.",
				"대부분의 DBMS는 (   ) 구조의 인덱스를 지원한다.",
				"SQL 함수는 DBMS가 제공하는 내장 함수와 사용자가 필요에 따라 직접 정의하는 (   )2가지로 분류한다.",
				"(   )는 미리 작성되어 DBMS에 저장된 연관된 SQL 문장들의 묶음이다.",
				"(   )는 실행 결과의 행을 한 번에 하나씩 처리하기 위해 테이블의 행을 순차적으로 가리키는 객체이다.",
				"(   ) 테이블은 트리거를 위해 변경후의 값을 일시적으로 저장하는 테이블로서 새로 삽입되는 행의 값을 가리키는 지정자 역할을 한다.",
				"(   )은 한 묶음으로 처리되어야 하는 데이터베이스 변경 명령어들의 집합이다.",
				"트랜잭션이 자동으로 시작되지만 반드시 사용자가 커밋이나 롤백문을 명시적으로 지정해야 커밋되는 트랜잭션 모드를 (   )커밋 트랜잭션이라고 한다.",
				"데이터베이스 캐시 안의 데이터 페이지가 성공적으로 변경되면 데이터베이스 파일에 쓰여지기 전에 로그 파일에 먼저 기록 되어야하는 특성을 (   )이라고 한다.",
				"(   )은 다수 트랜잭션의 동시성 제어 기법 중 대표적인 기법이다.",
				"오손 데이터 읽기는 발생하지 않지만 반복 불가능 읽기, 유령 데이터 읽기 문제가 여전히 발생하는 트랜잭션 고립 수준은 (   )이다." 
]

answers = [
    "데이터", "데이터베이스", "CIO", "데이터 일관성", "데이터 무결성", "DBMS", "DataBase Administrator", "SQL",
    "DBMS", "OODM", "데이터모델", "개념스키마", "데이터베이스 스키마", "데이터사전", "물리적 데이터 독립성", "제약조건", "코드", "도메인", "릴레이션",
    "최소성", "슈퍼키", "대리키", "외래키", "릴레이션, 튜플, 차수, 카디널리티", "외부 조인", "집합, 관계", "카티션 프로덕트", "합병", "셀렉트",
    "조인", "자연 조인", "동등", "세미 조인", "외부", "질의 트리", "Structured Query Language", "내장 방식", "USE", "*", "LIMIT",
    "HAVING", "AS", "부질의문", "IN", "EXISTS", "상관질의문", "n-1", "DESC", "REVOKE", "보안", "B-트리", "사용자 정의 함수",
    "저장 프로시저", "커서", "Inserted", "트랜잭션", "명시적", "WAL", "로크or잠금", "수준1"
]

num_questions = len(questions)
num_questions_to_show = 5  # 15문제 생성. 풀고싶은 만큼 숫자 설정하면 됨
correct_count = 0

# 틀린 문제를 저장하는 리스트
incorrect_indexes = []

while correct_count < num_questions_to_show:
    # 문제를 섞음
    question_indexes = random.sample(range(num_questions), num_questions)
    
    for i in range(num_questions_to_show):
        index = question_indexes[i]
        question = questions[index]
        answer = answers[index]

        print(f"문제 {correct_count + 1}: {question}")

        # 사용자에게 정답 입력 받기
        user_answer = input("정답을 입력하세요: ")

        # 정답 확인
        if user_answer.lower() == answer.lower():
            print("정답입니다!")
            correct_count += 1
        else:
            print(f"틀렸습니다. 정답은 {answer}입니다.")
            correct_count += 1
            # 틀린 문제의 인덱스를 저장
            incorrect_indexes.append(index)

        print()

# 틀린 문제 다시 출제
for incorrect_index in incorrect_indexes:
    question = questions[incorrect_index]
    answer = answers[incorrect_index]

    print(f"틀린 문제 다시 출제: {question}")

    # 사용자에게 정답 입력 받기
    user_answer = input("정답을 입력하세요: ")

    # 정답 확인
    if user_answer.lower() == answer.lower():
        print("정답입니다!")
    else:
        print(f"틀렸습니다. 정답은 {answer}입니다.")

    print()

print("프로그램을 종료합니다.")
