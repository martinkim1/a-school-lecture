import random

def generate_questions_and_answers(semester):
    if semester == 1:
        questions = [
                "(   )는 현실 세계에서 관찰 또는 수집의 결과로 나타난 사실이다.",
				"수집된 데이터를 저장했다가 필요할 때 제공하는 역할은 정보 시스템의 핵심인 (   )가 담당한다.",
				"기업들이 독립적인 부서를 통해 조직의 전체 데이터를 관리하게 하고 (   )라는 최고 경영자를 임명하여 의사결정에 필요한 정보를 관장하게 하는 이유는 그만큼 기업 경쟁력의 핵심 요소이기 때문이다.",
				"(   )은 중복되거나 연관된 데이터 간의 의미적 불일치성 혹은 모순성이 없는 상태를 말한다.",
				"(   )은 저장된 데이터 값이 현실 세계의 실제 값과 얼마나 정확히 일치하는지를 뜻하는 의미적 정확성을 말한다.",
				"데이터베이스 시스템에서는 모든 응용 프로그램이나 사용자들은 (   )를 통해서만 데이터 처리가 가능하다.",
				"데이터베이스 관리자인 DBA는 (   )의 약어이다.",
				"(   ) 용어는 원래 좁은 의미에서는 데이터 검색을 위한 데이터 조작어를 의미했지만 현재 넓은 의미에서는 데이터의 검색뿐만 아니라 입력, 수정, 삭제 그리고, 데이터 정의 기능 까지를 포함하는 광범위한 기능을 가진 독립적인 언어를 뜻하는 것으로 사용되고 있다.",
				"(   )는 데이터베이스를 효율적으로 관리하고 데이터베이스에 대한 데이터 요청을 처리하는 소프트웨어이다.",
				"(   ) 데이터 모델은 객체 단위의 저장 구조를 가지며 연관된 데이터 사이의 관계를 객체식별자로 표현하는 저장 방식이다.",
				"데이터베이스와 DBMS의 종류를 분류하는 가장 중요한 기준은 바로 (   )이다.",
				"(   )는 모든 데이터베이스 사용자들의 관점을 통합하여 조직이나 기관의 데이터베이스 전체를 명세한 데이터베이스 구조이다",
				"데이터베이스를 구성하는 모든 테이블들의 구조를 명세한 것이 (   )이다.",
				"(   )은 데이터베이스에 저장된 모든 부가 정보 즉, 데이터 정의나 명세뿐만 아니라 스키마와 이들 간의 사상 정보, 제약 조건 등을 저장하는 저장소이다.",
				"개념적 스키마에 영향이 없도록 하면서 데이터베이스의 물리적 구조를 변경할 수 있는 것을 (   )이라 한다.",
				"데이터 모델은 데이터 구조와 연산, (   ) 3가지 요소를 명세한다.",
				"관계형 데이터베이스(relational database)는 1970년대 IBM 연구소의 (   )가 제안한 관계형 데이터 모델에 기반하고 있다.",
				"각 속성이 취할 수 있는 모든 값들의 집합을 정의한 것을 (   )이라 한다.", "관계형 데이터베이스 스키마는 (   ) 스키마들의 모임이다.",
				"후보키는 유일성과 (   ) 조건을 모두 만족해야 한다.", "후보키를 포함하는 속성 집합은 모두 (   )가 된다.",
				"후보키 중에서 적절한 기본키 선정이 어려울 경우, 일련번호 같은 인위적인 속성을 추가로 생성하여 지정하는 기본키를 (   )라고 한다.",
				"기본키와 (   )는 릴레이션 간의 관계성을 표현하기 위해서 사용된다.",
				"관계형 데이터 모델에서 (ㄱ)(은)는 속성들을 갖는 2차원 테이블이며 속성은 각 열을, (ㄴ)(은)는 각 행을 의미한다. 또한, (ㄷ)(은)는 속성의 수를 의미하며, 행의 개수는 (ㄹ)(이)라 한다.",
				"(    )은 자연 조인 결과에 포함되지 않는 조인에 실패한 투플까지 모두 포함하도록 확장한 자연 조인 연산이다.",
				"관계 대수는 수학 집합 이론에 기반을 둔 (   ) 연산 그룹과 관계형 데이터 모델을 위해 추가된 (   ) 연산 그룹 2개의 그룹으로 분류한다.",
				"집합 연산(set operation) 그룹은 합집합, 교집합, 차집합, (   )연산을 포함한다.",
				"(   ) 가능하려면 두 릴레이션의 차수(속성 개수)가 같고 대응하는 속성의 순서와 도메인이 같아야 한다.",
				"(   ) 연산은 릴레이션에서 특정 투플을 추출하는 연산으로 연산자는 시그마 (sigma)를 사용한다.",
				"(   ) 연산은 결과적으로 카티션 프로덕트의 결과 릴레이션 중에서 '조인_조건식'을 만 족하는 투플을 셀렉트한 것과 같다.",
				"(   )은 동등 조인 결과 중에서 '조인조건식'에 사용된 중복 속성을 자동 제거한 조인이다.", "자연 조인은 (   )조인이면서 세타 조인이기도 하다.",
				"(   )은 자연 조인이 반환하는 결과 릴레이션 중에서 한쪽 릴레이션 속성만으로 한정하여 반환하는 제한적 자연 조인 연산이다.",
				"(   ) 조인을 수행하면 릴레이션 안의 모든 투플이 빠짐없이 결과 릴레이션에 포함된다.",
				"작성된 후보 관계 대수식은 DBMS 안의 질의 최적화 과정을 위해 내부적으로 (   )로 변환되어 표현된다.",
				"관계형 데이터베이스 표준 언어인 SQL은 (   )의 약어이다.", "SQL은 대화식 그리고 (   )의 2가지 방식으로 사용할 수 있다.",
				"univDB로 작업 대상 데이터베이스를 변경하는 명령은 (   ) univDB'이다.", "SELECT절의 ‘(*)'는 테이블의 모든 열 이름을 나열한 것과 같다.",
				"조건을 만족하는 결과가 존재하는지만 알고 싶거나 그 중 일부만 검색하고자 하는 경우 (   )키워드를 사용한다.",
				"집계 함수는 그룹 함수와 밀접한 관련성이 있으며 SELECT절이나 (   )절에만 사용할 수 있다.",
				"SELECT절에서 연산이나 집계 함수의 적용 결과로 새로운 값을 반환할 때 새로운 이름인 별칭을 정의하는 키워드는 (   )이다.",
				"(   )은 질의문 안에 중첩(   )되어 포함된 또 다른 SELECT 검색문을 말한다.",
				"WHERE절에 사용되는 (   ) 연산자는 괄호 안에 나열된 값들 중에서 하나라도 일치하는 경우 참(   )을 반환하는 연산자이다.",
				"(   ) 연산자는 부 질의문의 실행 결과로 반환되는 행이 존재하는지 존재 유무를 확인 하는 연산자이다.",
				"중첩 질의문 중에서 내부 질의의 WHERE절 검색조건식이 외부 질의에 선언된 테이블의 일부 열을 참조하는 질의를 (   )이라고 한다.",
				"FROM절에 명세한 조인 대상 테이블이 n개이면 (   )개의 조인 조건식이 필요하다.", "생성된 학생 테이블의 구조를 확인하는 명령은 ‘(   ) 학생'이다.",
				"계정에게 부여한 권한은 (   )명령문을 통해 다시 철회할 수 있다.", "뷰의 장점은 편의성, (   ), 재사용성, 독립성이다.",
				"대부분의 DBMS는 (   ) 구조의 인덱스를 지원한다.",
				"SQL 함수는 DBMS가 제공하는 내장 함수와 사용자가 필요에 따라 직접 정의하는 (   )2가지로 분류한다.",
				"(   )는 미리 작성되어 DBMS에 저장된 연관된 SQL 문장들의 묶음이다.",
				"(   )는 실행 결과의 행을 한 번에 하나씩 처리하기 위해 테이블의 행을 순차적으로 가리키는 객체이다.",
				"(   ) 테이블은 트리거를 위해 변경후의 값을 일시적으로 저장하는 테이블로서 새로 삽입되는 행의 값을 가리키는 지정자 역할을 한다.",
				"(   )은 한 묶음으로 처리되어야 하는 데이터베이스 변경 명령어들의 집합이다.",
				"트랜잭션이 자동으로 시작되지만 반드시 사용자가 커밋이나 롤백문을 명시적으로 지정해야 커밋되는 트랜잭션 모드를 (   )커밋 트랜잭션이라고 한다.",
				"데이터베이스 캐시 안의 데이터 페이지가 성공적으로 변경되면 데이터베이스 파일에 쓰여지기 전에 로그 파일에 먼저 기록 되어야하는 특성을 (   )이라고 한다.",
				"(   )은 다수 트랜잭션의 동시성 제어 기법 중 대표적인 기법이다.",
				"오손 데이터 읽기는 발생하지 않지만 반복 불가능 읽기, 유령 데이터 읽기 문제가 여전히 발생하는 트랜잭션 고립 수준은 (   )이다."
        ]
        answers = [
    			"데이터", "데이터베이스", "CIO", "데이터 일관성", "데이터 무결성", "DBMS", "DataBase Administrator", "SQL",
    			"DBMS", "OODM", "데이터모델", "개념스키마", "데이터베이스 스키마", "데이터사전", "물리적 데이터 독립성", "제약조건", "코드", "도메인", "릴레이션",
   				"최소성", "슈퍼키", "대리키", "외래키", "릴레이션, 튜플, 차수, 카디널리티", "외부 조인", "집합, 관계", "카티션 프로덕트", "합병", "셀렉트",
    			"조인", "자연 조인", "동등", "세미 조인", "외부", "질의 트리", "Structured Query Language", "내장 방식", "USE", "*", "LIMIT",
   				"HAVING", "AS", "부질의문", "IN", "EXISTS", "상관질의문", "n-1", "DESC", "REVOKE", "보안", "B-트리", "사용자 정의 함수",
    			"저장 프로시저", "커서", "Inserted", "트랜잭션", "명시적", "WAL", "로크or잠금", "수준1"
        ]
    elif semester == 2:
        questions = [
				"데이터 (   )은 불필요한 데이터 중복으로 인해 릴레이션 처리 시 발생하는 부작용을 말한다.",
				"데이터 이상 현상 방지를 위해 규칙에 따라 릴레이션을 분할하는 과정을 (   )라고 한다.",
				"함수 (   ）은 같은 릴레이션 안의 속성 간에 특정 속성 값이 함수적으로 다른 속성 값을 결정하는 종속 관계를 말한다.",
				"제1정규형의 문제점을 해결하려면 (   ) 함수 종속성을 제거해야 한다.",
				"(   ) 함수 종속성은 기본키에 속하지 않은 일반 속성 값이 기본키에 속하지 않는 또 다른 일반 속성 값을 결정함을 의미한다.",
				"E-R 모델은 현실 세계를 (   )와 관계를 이용하여 개념적 구조로 표현하는 방법이다.",
				"(   ) 속성은 값을 저장하지 않아도 다른 속성 값으로부터 계산될 수 있는 속성으로 점선의 타원으로 표시된다.",
				"보통 강개체와 약개체는 일대다의 (   ) 관계를 맺게 되며 약개체는 관계에 (   ) 참여하게 된다.",
				"E-R 다이어그램에서 (   ) 관계는 IS-A 관계라고도 하며 역삼각형으로 표현된다.",
				"관계 (   )는 관계를 맺는 두 개체 집합간의 사상 형태를 정의한다.",
				"데이터베이스 설계의 핵심은 작성된 E-R 다이아그램을 (   ) 데이터 모델로 변환하는 논리적 데이터 설계 과정이다.",
				"요구사항 명세서에서 고유한 명칭(이름, 번호)을 보유하는 존재는 (   )로 표현하는 것이 바람직하다.",
				"E-R 다이어그램의 관계는 관계 (   )에 따라서 관계형 데이터 모델로의 변환 과정이 다르다.",
				"(   ) 설계는 릴레이션 스키마들을 실제 DBMS 안에 물리적인 저장 구조를 생성하는 SQL 명령어 문장으로 변환한다.",
				"E-R 다이아그램에서 일대다 관계는 하나의 (   )키 속성으로 변환된다.",
				"ERwin에서 결국 대다다 관계선은 새로운 (   ) 엔터티와의 2개의 일대다 관계선으로 변환되어야만 한다.",
				"ERwin에서 식별 관계는 자식 엔터티를 약 엔터티 즉, (   ) 사각형으로 표시하고 비식별 관계는 자식 엔터티를 강 엔터티 즉, (   )사각형으로 표시한다.",
				"(   )는 조직의 일부 사용자만 사용할 목적으로 주제 범위를 제한하여 구축한 분석 데이터 저장소이다.",
				"(   ) 모델링은 높은 연관성을 갖는 데이터들을 데이터웨어하우스 안에서 다차원성을 유지하도록 구조화하는 것이다.",
				"다차원 데이터베이스에서 데이터는 '(   )' 라고 불리는 특별한 다차원 배열 구조의 '셀'안에 저장된다.",
				"같은 차원 안의 수준들 간의 수직적 상하 관계를 (   )이라 하며 상위 수준의 개념으로부터 하위 수준의 개념으로 차원 멤버들을 계층적으로 조직화한다.",
				"스타 스키마는 하나의 (   ) 테이블을 중심으로 주위에 여러 개의 차원 테이블들이 연결되는 방사성 구조이다.",
				"수집한 데이터들의 상관관계를 분석하면 정보를 발견할 수 있다. 정보를 조직화하면 지식이 만들어지고 지식을 구조화하면 (   )가 된다.",
				"데이터웨어하우스, 데이터마트나 데이터마이닝에서는 수집된 데이터를 분석이 용이하도록 통일된 형태로 변환하는 과정을 (   )이라고 한다.",
				"하둡 (   ) 시스템은 하둡 프레임워크를 이루고 있는 다양한 서브 프로젝트들의 모임이다.",
				"저가의 서버라도 서버 자체를 더 추가한 뒤 서버드를 묶어 분산 병령 처리함으로싸 전체 시스템의 용량을 키우는 방식을 수평적 또는 스케일 (   ) 확장 방식이라고 한다.",
				"(   )은 데이터 집합으로부터 의미있는 통계적 규칙이나 패턴을 찾아냄으로써 데이터의 새로운 가치를 찾아내는 기법이다.",
				"(   )은 정보와 그래픽의 합성어로 분석 결과를 쉽게 이해할 수 있도록 그래픽과 텍스트를 조합하여 시각적으로 표현하는 방법이다.",
				"몽고DB에서 가용성을 향상시키기 위한 (   )은 데이터베이스의 데이터를 수평 분할하여 여러 서버 분산 저장하는 방식이다.",
				"몽고DB의 기본 구성 요소중에서 (   )은 문서의 모음으로 동적 스키마를 갖는 테이블과 같다.",
				"몽고DB (   )은 문서에 대한 질의뿐만 아니라 관리나 실행중인 인스턴스를 점검하는데 유용한 도구로써 자바스크립트 해석 기능을 가지고 있어 자바스크립트 프로그램 작성과 실행이 가능하다.",
				"(   ) 명령어 함수는 특정 문서를 찾아서 새로운 문서로 교체한다.",
				"몽고DB에서 컬렉션에 문서 하나를 추가하는 명령어는 (   )이다."
        ]
        answers = [
				"이상현상", "정규화", "종속성", "부분", "이행성", "개체", "유도", "식별, 전체", "일반화",
				"카디널리티", "관계형", "개체", "카디널리티", "물리적", "외래", "중간", "둥근, 직", "데이터웨어하우스",
				"다차원", "큐브", "개념계층", "사실", "지혜", "ETL", "에코", "아웃", "데이터 마이닝", "인포그래픽",
				"샤딩", "컬렉션", "쉘", "replaceOne( )", "insertOne( )"
        ]
    else:
        print("잘못된 입력입니다. 1 또는 2 중 하나를 입력하세요.")
        return None, None

    num_questions = len(questions)
    return questions, answers, num_questions

print("***** 데이터베이스 빈칸문제 출제 프로그램 *****")
print("스페이스(공백)을 구별합니다. 정확히 입력해주세요.")

# 사용자로부터 학기 선택 받기
semester = int(input("중간고사(1) 기말고사(2) 선택하세요: "))

questions, answers, num_questions = generate_questions_and_answers(semester)

if questions is not None and answers is not None:
    num_questions_to_show = 10  # 15문제 생성. 풀고싶은 만큼 숫자 설정하면 됨
    correct_count = 0

 # 틀린 문제를 저장하는 리스트
incorrect_indexes = []

while correct_count < num_questions_to_show:
    # 문제를 섞음
    question_indexes = random.sample(range(num_questions), num_questions)

    for i in range(num_questions_to_show):
        if i < len(question_indexes):
            index = question_indexes[i]
            question = questions[index]
            answer = answers[index]
        else:
            break

        print(f"문제 {correct_count + 1}: {question}")

        # 사용자에게 정답 입력 받기
        user_answer = input("정답을 입력하세요: ")

        # 정답 확인
        if user_answer.lower() == answer.lower():
            print("정답입니다!")
            correct_count += 1
        else:
            print(f"틀렸습니다. 정답은 {answer}입니다.")
            correct_count += 1
            # 틀린 문제의 인덱스를 저장
            incorrect_indexes.append(index)

        print()

# 틀린 문제 다시 출제
for incorrect_index in incorrect_indexes:
    question = questions[incorrect_index]
    answer = answers[incorrect_index]

    print(f"틀린 문제 다시 출제: {question}")

    # 사용자에게 정답 입력 받기
    user_answer = input("정답을 입력하세요: ")

    # 정답 확인
    if user_answer.lower() == answer.lower():
        print("정답입니다!")
    else:
        print(f"틀렸습니다. 정답은 {answer}입니다.")

    print()

print("프로그램을 종료합니다.")
